<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="Be a better man"><meta name="keywords" content="Hexo, iOS"><title>探究 Block - iosTangtang</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/iosTangtang"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">探究 Block</h1><ul class="meta"><li><i class="icon icon-author"></i>iosTangtang</li><li><i class="icon icon-clock"></i>48 Minutes</li><li><i class="icon icon-calendar"></i>2017年5月20日</li></ul></div></div><div class="article-content" style="max-width:800px"><h2 id="什么是-Block"><a href="#什么是-Block" class="headerlink" title="什么是 Block"></a>什么是 Block</h2><p>Block实际上就是 OC 语言对闭包的实现，所谓的闭包就是一个函数，或者是一个指向函数的指针，加上这个函数执行的变量，也就是闭包允许一个函数访问声明该函数运行上下文中的变量，甚至可以访问不同运行上下文中的变量。</p>
<p>通俗点来讲就是，带有局部变量的匿名函数，差不多与C语言中的函数指针类似，可以当做参数传递，而且可以没有名字。</p>
<h2 id="Block-的语法"><a href="#Block-的语法" class="headerlink" title="Block 的语法"></a>Block 的语法</h2><p>Block的完整语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^ returnType (argument list) &#123;expressions&#125;</div></pre></td></tr></table></figure>
<p>与 C 语言函数的区别：</p>
<ul>
<li>没有函数名</li>
<li>带有 “^” 符号</li>
</ul>
<p>所以我们可以像下面这样写一个 block：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^ int (int index) &#123; return index; &#125;</div></pre></td></tr></table></figure>
<p>当然也可以写省略格式的 block，比如省略返回值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^ (int index) &#123; return index; &#125;</div></pre></td></tr></table></figure>
<p>省略返回值时，如果 block 体中存在 return 语句，则返回值类型为使用 return 返回的类型，比如上面 block 的返回类型为 int 类型。</p>
<p>当然如果没有参数的话，也可以省略参数列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^ &#123; NSLog(@&quot;1111&quot;); &#125;</div></pre></td></tr></table></figure>
<p>在像如上这样写，实际上也相当于生成了可赋值给 block 类型的值，我们可以像下面这样接收：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int (^myBlock)(int) = ^ int (int index) &#123; return index; &#125;</div><div class="line">int (^block1)(int) = myBlock;</div></pre></td></tr></table></figure>
<p>如果每次写 block 变量的时候都这样写，那不是很麻烦吗。我们可以使用 typedef 来定义一个 block 类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef int(^MyBlock)(int);</div></pre></td></tr></table></figure>
<p>然后就可以使用 MyBlock 这个类型来定义变量了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MyBlock blk_t = ^ (int index) &#123; return index; &#125;</div></pre></td></tr></table></figure>
<h2 id="Block-截获变量"><a href="#Block-截获变量" class="headerlink" title="Block 截获变量"></a>Block 截获变量</h2><p>block 中，截获自动变量是什么意思呢？所谓的自动变量，其实就相当于 C 语言中的局部变量。我们来看一下下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int val = 10;</div><div class="line">MyBlock block = ^ &#123; NSLog(@&quot;%d&quot;, val); &#125;;</div><div class="line">val = 20;</div><div class="line">block();</div></pre></td></tr></table></figure>
<p>打印结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2017-04-04 15:13:36.206 Block[850:99999] 10</div></pre></td></tr></table></figure></p>
<p>也就是说，如果在 block 中使用到上文中的局部变量的话，block 会将其保存到自身的内部中，不管下文那个变量怎么变，在 block 调用的时候，用的变量值都是之前截获的那个值。那么，可以在 block 中修改值吗?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int val = 10;</div><div class="line">MyBlock block = ^ &#123;</div><div class="line">    NSLog(@&quot;%d&quot;, val);</div><div class="line">    val = 20;</div><div class="line">&#125;;</div><div class="line">val = 20;</div><div class="line">block();</div></pre></td></tr></table></figure>
<p>这样写的结果就是，编译报错。我们可以使用 <code>__block</code> 修饰符来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__block int val = 10;</div><div class="line">MyBlock block = ^ &#123;</div><div class="line">    val = 20;</div><div class="line">    NSLog(@&quot;%d&quot;, val);</div><div class="line">&#125;;</div><div class="line">block();</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2017-04-04 15:21:03.387 Block[883:106008] 20</div></pre></td></tr></table></figure>
<p>说明我们修改成功了。当然对于全局变量和 static 修饰的变量不需要使用 <code>__block</code> 就可以改变值，至于为什么，我们一会儿再说。那么，对于 OC 中的变量，调用变更改对象的方法时，也会报错吗？试下下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *array = [NSMutableArray array];</div><div class="line">MyBlock block = ^ &#123;</div><div class="line">    [array addObject:[[NSObject alloc] init]];</div><div class="line">    NSLog(@&quot;%@&quot;, array);</div><div class="line">&#125;;</div><div class="line">block();</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2017-04-04 15:24:27.507 Block[897:109262] (</div><div class="line">    &quot;&lt;NSObject: 0x6180000148e0&gt;&quot;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>这样做是没有问题的，但是如果对变量赋值，就会报错。比如下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">MyBlock block = ^ &#123;</div><div class="line">    [array addObject:[[NSObject alloc] init]];</div><div class="line">    NSLog(@&quot;%@&quot;, array);</div><div class="line">    array = nil;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样会造成编译错误，同样我们可以使用 <code>__block</code> 修饰符来进行变量修改。</p>
<h6 id="block-与-C-语言数组"><a href="#block-与-C-语言数组" class="headerlink" title="block 与 C 语言数组"></a>block 与 C 语言数组</h6><p>注意，在 block 中使用 C 语言数组时需要注意可能会造成编译错误。比如下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const char text[] = &quot;text&quot;;</div><div class="line">MyBlock block = ^ &#123;</div><div class="line">    NSLog(@&quot;%c&quot;, text[2]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样会造成编译报错，因为在 block 中并没有实现对 C 语言数组的截获，可以将其改成指针形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const char *text = &quot;text&quot;;</div><div class="line">MyBlock block = ^ &#123;</div><div class="line">    NSLog(@&quot;%c&quot;, text[2]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Block-的实现"><a href="#Block-的实现" class="headerlink" title="Block 的实现"></a>Block 的实现</h3><p>block 的实质是什么？其实看过了 Apple 的一些源码实现之后可以猜到，其实际上底层还是转换成 C++ 的，通过支持 block 的编译器，作为 C++ 代码被编译。</p>
<p>但是上面只是猜测，实际上是什么，我们还是得去看看。可以通过以下命令将 OC 代码重写成 C++ 代码：</p>
<blockquote>
<p>clang -rewrite-objc 源代码文件名</p>
</blockquote>
<p>对下面代码进行一次转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int val = 10;</div><div class="line">MyBlock block = ^ &#123;</div><div class="line">    NSLog(@&quot;%d&quot;, val);</div><div class="line">&#125;;</div><div class="line">block();</div></pre></td></tr></table></figure>
<p>转换之后的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">struct __block_impl &#123;</div><div class="line">  void *isa;</div><div class="line">  int Flags;</div><div class="line">  int Reserved;</div><div class="line">  void *FuncPtr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">#ifdef __OBJC_EXPORT_BLOCKS</div><div class="line">extern &quot;C&quot; __declspec(dllexport) void _Block_object_assign(void *, const void *, const int);</div><div class="line">extern &quot;C&quot; __declspec(dllexport) void _Block_object_dispose(const void *, const int);</div><div class="line">extern &quot;C&quot; __declspec(dllexport) void *_NSConcreteGlobalBlock[32];</div><div class="line">extern &quot;C&quot; __declspec(dllexport) void *_NSConcreteStackBlock[32];</div><div class="line">#else</div><div class="line">__OBJC_RW_DLLIMPORT void _Block_object_assign(void *, const void *, const int);</div><div class="line">__OBJC_RW_DLLIMPORT void _Block_object_dispose(const void *, const int);</div><div class="line">__OBJC_RW_DLLIMPORT void *_NSConcreteGlobalBlock[32];</div><div class="line">__OBJC_RW_DLLIMPORT void *_NSConcreteStackBlock[32];</div><div class="line">#endif</div><div class="line">#endif</div><div class="line">#define __block</div><div class="line">#define __weak</div><div class="line"></div><div class="line">typedef void(*MyBlock)(void);</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  int val;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _val, int flags=0) : val(_val) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    int val = __cself-&gt;val; // bound by copy</div><div class="line"></div><div class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_nj_bxfgkgws0dbcjwm4psdxt2qm0000gn_T_main_63c9d1_mi_0, val);</div><div class="line"> &#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; </div><div class="line">        int val = 10;</div><div class="line">        MyBlock block = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, val));</div><div class="line">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于转换后出现的 9W 多行代码有点小小的无语，抛弃一些与 block 无关的代码后，关于 block 的代码都在上面了，我们慢慢来看下这个源代码。</p>
<p>首先来看看最初的打印语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^ &#123; NSLog(@&quot;%d&quot;, val); &#125;;</div></pre></td></tr></table></figure>
<p>转换之后的 NSLog 代码，我们在一个静态函数里面看到了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    int val = __cself-&gt;val; // bound by copy</div><div class="line"></div><div class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_nj_bxfgkgws0dbcjwm4psdxt2qm0000gn_T_main_63c9d1_mi_0, val);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在 block 中所谓的匿名函数，实际上还是被当做了普通的 C 语言函数来处理。这个函数的参数是一个 <code>__main_block_impl_0</code> 类型的指针，从 <code>__cself</code> 这个变量名，我们可以猜到，这个是不是相当于 OC 中的 self 呢？实际上就是这样的，这个参数的作用于 OC 中的 self 关键字功能差不多。这块用来获取到 block 中截获的自动变量。</p>
<p>再来看看 block 的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">struct __block_impl &#123;</div><div class="line">  void *isa;</div><div class="line">  int Flags;</div><div class="line">  int Reserved;</div><div class="line">  void *FuncPtr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  int val;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _val, int flags=0) : val(_val) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们可以看到两个结构体类型，先说说第一个结构体 __block_impl，这个结构体的成员变量分别为 isa 指针、某种标志、今后升级所需要的的区域以及函数指针。从这个结构体中的 isa 成员可以看出，在 OC 中 block 被视为对象来处理。</p>
<p>再来看看第二个结构体 <code>__main_block_impl_0</code>，这里面的成员变量有<code>__block_impl</code>结构体变量，还有一个 __main_block_desc_0 结构体变量，还有一个看起来很熟悉，就是我们定义的自动变量，block 在自己的结构体里面也声明了一个一样的变量来记录上文中的自动变量。然后是一个构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _val, int flags=0) : val(_val) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面主要是对 block 的一些初始化。可以看到 isa 指针指向了 <code>_NSConcreteStackBlock</code>，这个东西是什么呢？我们一会儿来说。</p>
<p>我们再来看看 __main_block_desc_0 这个结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div></pre></td></tr></table></figure>
<p>这里面有两个成员变量，从变量名可以猜出这两个变量分别是今后升级所需的区域和 block 的大小。</p>
<p>再来看看主函数里面的 block 定义和调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MyBlock block = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, val));</div><div class="line">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div></pre></td></tr></table></figure>
<p>去掉复杂的类型转换后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MyBlock block = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, val);</div><div class="line"></div><div class="line">(*block-&gt;impl.FuncPtr)(block);</div></pre></td></tr></table></figure></p>
<p>可以看到其实就是调用初始化方法，初始化方法中传入三个参数，第一个参数为函数指针，第二个参数为静态全局变量初始化的 <code>__main_block_desc_0</code> 结构体变量，第三个参数就是上文中的需要截获的自动变量，通过这个初始化方法得到 block 变量，在通过调用 block 中 impl 中的函数指针来调用函数，并将自身作为参数传递进去，也就是上面说的 __cself 参数。</p>
<p>至此，整个 block 的过程就理清楚了。但是，这里还有一个东西没有说清楚，那就是 _NSConcreteStackBlock，这东西究竟是什么呢？要说明这个，就要再提一下 Runtime 了。我们来看一张图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1975281-cc44a16eb3f252d3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Runtime结构图"></p>
<p>其实一般讲到 Runtime 的文章中，都会多多少少出现这个图。这个图说明了 isa 指针的作用以及指向。那么对于 block 的 isa 指针，既然要将其作为 OC 对象，自然也应该符合这张图的描述。一个实例对象的 isa 指针指向的是其类对应的类对象，这个类对象存储着对象所需要的实例对象和实例方法，类对象的 isa 指针则指向的是元类，元类中存储的是类方法，也就是说，所谓的类对象和元类，都存储着构造一个对象所需要的信息。那么对于 block 来说，我们也可以这么理解，block 中 isa 指针指向的其实也就是构造这个 block 对象所需要的信息，也就是 <code>_NSConcreteStackBlock</code> 的作用。也就是说，构造 block 所需要的类信息存储在了 <code>_NSConcreteStackBlock</code> 中。</p>
<h2 id="截获自动变量与-block-修饰符"><a href="#截获自动变量与-block-修饰符" class="headerlink" title="截获自动变量与 __block 修饰符"></a>截获自动变量与 __block 修饰符</h2><p>前面提到了，如果在 block 中使用到上文中的自动变量，那么这个自动变量会被保存到 block 中。这种保存其实就是在 <code>__main_block_impl_0</code> 结构体中声明一个跟自动变量一样的变量，然后在初始化函数中将自动变量作为参数传进去保存在相应的变量上，然后当使用到的时候，访问即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 结构体</div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  int val;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _val, int flags=0) : val(_val) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 初始化</div><div class="line">MyBlock block = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, val);</div><div class="line"></div><div class="line">// 使用</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    int val = __cself-&gt;val; // bound by copy</div><div class="line"></div><div class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_nj_bxfgkgws0dbcjwm4psdxt2qm0000gn_T_main_63c9d1_mi_0, val);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这样子当初始化函数调用完之后，被赋值的自动变量理论上是不能被修改的，所以当编译器检测出对被捕获的变量进行赋值的操作时会报错。这样子就无法在 block 中修改值了，极为不便。</p>
<p>在 C 语言中，有一类变量是可以在 block 中修改值的：</p>
<ul>
<li>静态变量</li>
<li>静态全局变量</li>
<li>全局变量</li>
</ul>
<p>我们可以在代码中加入这些值来测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">typedef void(^MyBlock)(void);</div><div class="line">int global_val = 5;</div><div class="line">static int static_global_val = 15;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        static int static_val = 20;</div><div class="line">        MyBlock block = ^ &#123;</div><div class="line">            NSLog(@&quot;%d %d %d&quot;, global_val, static_global_val, static_val);</div><div class="line">        &#125;;</div><div class="line">        block();</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后使用上面提到的命令将其转为 C++ 代码，可以看到如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">int global_val = 5;</div><div class="line">static int static_global_val = 15;</div><div class="line"></div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  int *static_val;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_static_val, int flags=0) : static_val(_static_val) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">    int *static_val = __cself-&gt;static_val; // bound by copy</div><div class="line"></div><div class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_nj_bxfgkgws0dbcjwm4psdxt2qm0000gn_T_main_599909_mi_0, global_val, static_global_val, (*static_val));</div><div class="line">&#125;</div><div class="line"></div><div class="line"> MyBlock block = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val));</div></pre></td></tr></table></figure>
<p>可以看到，对于全局变量，block 是不做捕获的，因为在 C 语言中，全局变量的作用域是整个文件。对 static 类型的变量，block 在结构体中声明了一个对应类型的指针，然后在初始化时将静态变量的地址作为参数传入，在使用的时候调用即可。因为静态变量的地址是固定的，所以 block 采用记录变量地址的方法即可。</p>
<p>那么，似乎这种方法也适合自动变量。但是并不是，如果按照这种方法记录自动变量的地址，那么当这个自动变量超出作用域范围的时候 block 还没被调用，自动变量就会被废弃掉，之后在其他地方如果调用 block，则 block 中就会出现野指针访问。那么，对于自动变量，我们该怎么去做？</p>
<p>其实上文提到了，使用 <code>__block</code> 修饰符修饰相应的变量即可。可是，__block 是怎么实现对自动变量的存储并可以修改的？我们对代码进行相应的修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__block int val = 20;</div><div class="line">MyBlock block = ^ &#123;</div><div class="line">    val = 10;</div><div class="line">    NSLog(@&quot;%d&quot;, val);</div><div class="line">&#125;;</div><div class="line">block();</div></pre></td></tr></table></figure>
<p>再次使用命令进行转化，可以看到如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_val_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_val_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int val;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_val_0 *val; // by ref</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, int flags=0) : val(_val-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_val_0 *val = __cself-&gt;val; // bound by ref</div><div class="line"></div><div class="line">    (val-&gt;__forwarding-&gt;val) = 10;</div><div class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_nj_bxfgkgws0dbcjwm4psdxt2qm0000gn_T_main_c4a31c_mi_0, (val-&gt;__forwarding-&gt;val));</div><div class="line">&#125;</div><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;val, (void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">  void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class="line"></div><div class="line">__Block_byref_val_0 val = &#123;</div><div class="line">            (void*)0,</div><div class="line">            (__Block_byref_val_0 *)&amp;val,</div><div class="line">            0, </div><div class="line">            sizeof(__Block_byref_val_0), </div><div class="line">            20</div><div class="line">&#125;;</div><div class="line"></div><div class="line">MyBlock block = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, 570425344));</div></pre></td></tr></table></figure>
<p>可以看到代码一下子变多了。多了一个 <code>__Block_byref_val_0</code> 结构体，被截获的自动变量在 <code>__main_block_impl_0</code> 中被声明为了 <code>__Block_byref_val_0</code> 结构体变量，同时多了 <code>__main_block_copy_0</code> 和 <code>__main_block_dispose_0</code> 函数，同时在 <code>__main_block_desc_0</code> 中多了两个函数指针，指向的就是多出来的 copy 和 dispose 函数。在主函数中，被截获的自动变量被 <code>__Block_byref_val_0</code> 的结构体封装起来了，最终在 block 的构造参数中作为变量传入。我们来看看这个 <code>__Block_byref_val_0</code> 结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_val_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_val_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int val;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们可以看到里面有 isa 指针，自身类型的 <code>__forwarding</code> 指针，flags，这个结构体的 size，还有自动变量的值。在初始化时会根据这个自动变量来进行相应赋值。这里先不说明 forwarding 指针的作用。</p>
<p>那么，在给自动变量赋值的时候，发生了啥呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_val_0 *val = __cself-&gt;val; // bound by ref</div><div class="line"></div><div class="line">    (val-&gt;__forwarding-&gt;val) = 10;</div><div class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_nj_bxfgkgws0dbcjwm4psdxt2qm0000gn_T_main_c4a31c_mi_0, (val-&gt;__forwarding-&gt;val));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这里面是获取到 cself 中的 val 变量，然后通过 forwarding 去访问 val，这里的 block 持有 __Block_byref_val_0 的 val，而 val 中的 forwarding 持有了自身(从初始化该结构体的时候可以看出来)。这之间的关系可以通过如下图表示</p>
<p><img src="http://om50f51ai.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%888.20.24.png" alt="forwarding"></p>
<p>这里为什么要这样设计呢？一会儿再说。这里将 <code>__Block_byref_val_0</code> 放在 <code>__main_block_impl_0</code> 结构体外面主要是为了能够在多个 block 中使用 <code>__block</code> 变量。</p>
<h2 id="Block-的存储域"><a href="#Block-的存储域" class="headerlink" title="Block 的存储域"></a>Block 的存储域</h2><p>之前提到了 OC 中将 block 作为类来对待，类信息存储在 <code>_NSConcreteStackBlock</code> 中，其实这里的类信息并不仅仅只有这一个，总共有如下三个：</p>
<ul>
<li>_NSConcreteStackBlock</li>
<li>_NSConcreteGlobalBlock</li>
<li>_NSConcreteMallocBlock</li>
</ul>
<p>从字面意思上看，可以看出来 <code>_NSConcreteStackBlock</code> 是表示栈上的 block，<code>_NSConcreteGlobalBlock</code> 是表示全局的 block，<code>_NSConcreteMallocBlock</code> 是表示堆上的 block。其内存分配如下：<br>| 类信息       | 对象的存储区域         |<br>| :————-: |:————-:|<br>| _NSConcreteStackBlock   | 栈上 |<br>| _NSConcreteGlobalBlock      | 程序的数据区 |<br>| _NSConcreteMallocBlock | 堆上 |</p>
<p>之前的一些例子都是在栈上的，而当你声明一个全局的 block 变量的时候，其实根据 _NSConcreteGlobalBlock 的类信息生成的变量。而因为在声明全局变量的地方不能使用自动变量，所以也就不存在自动变量的截获问题了。即使 block 不在全局声明，只要其不做自动变量的截获，就可以视为一个全局的 block。</p>
<p>那么，_NSConcreteMallocBlock 在何时使用呢？如果是设置在栈上的 block，那么在变量作用域结束时，相应的 block 也会被废弃，同样的，对应的 __block 也会被废弃。如下图：<br><img src="http://om50f51ai.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%888.34.49.png" alt="栈上的 block 废弃"></p>
<p>这个时候，我们可以将栈上的 block 复制到堆上，这样在栈上的 block 被废弃的时候，我们依然可以使用堆上的 block。如下图：<br><img src="http://om50f51ai.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%888.36.48.png" alt="堆上的 block"></p>
<p>这样子，block 的 isa 指针指向的就是 <code>_NSConcreteMallocBlock</code>。这时候谈谈 forwarding 指针的作用，我们把 block 复制到了堆上，以及 <code>__block</code> 变量，要保证不管在栈上还是堆上的 <code>__block</code> 变量都能被正确访问，就需要将栈上的 forwarding 指针指向堆上的 <code>__block</code> 变量，这样子不管在栈上还是堆上的 <code>__block</code> 变量都能保证被正确访问。这就是 forwarding 指针的作用。像下图这样：<br><img src="http://om50f51ai.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%888.41.57.png" alt="forwarding"></p>
<p>那么，我们怎么去复制 block 呢？其实在 ARC 中，编译器大多数情况下能够自动判断并在合适的时机将 block 从栈上复制到堆上。比如当 block 作为返回值返回的时候，编译器就会自动将 block 从栈上复制到堆上。也有一些情况下，我们需要自己手动复制，比如向方法或函数中的参数传递 block 时，我们需要通过调用 copy 方法来实现复制到堆上的操作。但是像一些系统中的 API 可以不用调用 copy 方法，因为其在方法中适当的对 block 进行了复制。</p>
<p>那么，对堆上的 block 或者全局的 block 调用 copy 方法会发生什么呢？</p>
<table>
<thead>
<tr>
<th style="text-align:center">类信息</th>
<th style="text-align:center">副本源的存储区域</th>
<th style="text-align:center">复制效果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">_NSConcreteStackBlock</td>
<td style="text-align:center">栈上</td>
<td style="text-align:center">从栈上复制到堆上</td>
</tr>
<tr>
<td style="text-align:center">_NSConcreteGlobalBlock</td>
<td style="text-align:center">程序的数据区</td>
<td style="text-align:center">什么也不做</td>
</tr>
<tr>
<td style="text-align:center">_NSConcreteMallocBlock</td>
<td style="text-align:center">堆上</td>
<td style="text-align:center">引用计数增加</td>
</tr>
</tbody>
</table>
<p>所以不管在哪里调用 copy 都不会出现问题，可以在不确定的时候调用 copy 方法。</p>
<p>那么，当 block 从栈复制到堆上时，对 __block 会有什么影响吗？</p>
<table>
<thead>
<tr>
<th style="text-align:center">__block的配置存储域</th>
<th style="text-align:center">block 从栈复制到堆上的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">栈</td>
<td style="text-align:center">从栈上复制到堆上并被 block 持有</td>
</tr>
<tr>
<td style="text-align:center">堆</td>
<td style="text-align:center">被 block 持有</td>
</tr>
</tbody>
</table>
<p><img src="http://om50f51ai.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%888.53.16.png" alt=""></p>
<p><img src="http://om50f51ai.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-04%20%E4%B8%8B%E5%8D%888.53.22.png" alt=""></p>
<p>从表和图中我们可以知道，相应的操作思想与引用计数思想完全相同。</p>
<h2 id="截获对象"><a href="#截获对象" class="headerlink" title="截获对象"></a>截获对象</h2><p>上面大部分的例子都是用基本数据类型来说的，我们来试试使用对象类型的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *array = [NSMutableArray array];</div><div class="line">MyBlock block = ^ &#123;</div><div class="line">    [array addObject:[[NSObject alloc] init]];</div><div class="line">    NSLog(@&quot;%@&quot;, array);</div><div class="line">&#125;;</div><div class="line">block();</div></pre></td></tr></table></figure></p>
<p>转换之后的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  NSMutableArray *array;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSMutableArray *_array, int flags=0) : array(_array) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  NSMutableArray *array = __cself-&gt;array; // bound by copy</div><div class="line"></div><div class="line">    ((void (*)(id, SEL, ObjectType))(void *)objc_msgSend)((id)array, sel_registerName(&quot;addObject:&quot;), (id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;)));</div><div class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_nj_bxfgkgws0dbcjwm4psdxt2qm0000gn_T_main_0dd23b_mi_0, array);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;array, (void*)src-&gt;array, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</div><div class="line"></div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;array, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;</div></pre></td></tr></table></figure></p>
<p>我们注意到，NSMutableArray 同样被保存在结构体中声明的 NSMutableArray 变量中，可是我们都知道，C 语言中不存在引用计数这一概念，那么其实怎么对 array 进行内存管理的呢？这时候我们需要注意一下 <code>__main_block_copy_0</code> 和 <code>__main_block_dispose_0</code> 两个函数，这两个函数里面分别通过调用 <code>_Block_object_assign</code> 和 <code>_Block_object_dispose</code> 函数，并将 array 作为参数传入。也就是说，block 其实是通过 <code>_Block_object_assign</code> 函数持有对象，通过 <code>_Block_object_dispose</code> 来对引用计数减一，也就是相当于 MRC 下的 release 函数。</p>
<p>那么，这两个函数的调用时机是什么时候？</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">调用时机</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">copy</td>
<td style="text-align:center">栈上的 block 被复制到堆上时</td>
</tr>
<tr>
<td style="text-align:center">dispose</td>
<td style="text-align:center">堆上的 block 被释放时</td>
</tr>
</tbody>
</table>
<h2 id="Block-的循环引用"><a href="#Block-的循环引用" class="headerlink" title="Block 的循环引用"></a>Block 的循环引用</h2><p>之前多次提到了循环引用，这个也是被大多数 iOS 开发者所熟知的东西。这里就不做过多说明。说一下循环引用的解决吧。</p>
<p>循环引用的解决，除了常用的 <code>__weak</code>。其实还可以通过 <code>__block</code> 来解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">typedef void(^MyObjectBlock)(void);</div><div class="line"></div><div class="line">@interface MyObject : NSObject &#123;</div><div class="line">    MyObjectBlock _blk;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)execBlock;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#import &quot;MyObject.h&quot;</div><div class="line"></div><div class="line">@implementation MyObject</div><div class="line"></div><div class="line">- (instancetype)init &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        __block typeof(self) temp = self;</div><div class="line">        _blk = ^ &#123;</div><div class="line">            NSLog(@&quot;self = %@&quot;, temp);</div><div class="line">            temp = nil;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)execBlock &#123;</div><div class="line">    _blk();</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        MyObject *obj = [[MyObject alloc] init];</div><div class="line">        [obj execBlock];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码就不会造成循环引用，但是前提是必须调用 execBlock 方法，否则还是会引起循环引用。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我们从 block 的概念，说到了语法和截获自动变量,再说到了其是如何实现的，再说到了 <code>__block</code> 修饰符的实现原理，又说到了 block 的存储域，最后说到了 block 循环引用的另一种解决方式。得益于 <strong>clang -rewrite-objc 源代码文件名</strong> 命令，我们可以探寻到 block 的本质，得知 block 的真相，获益匪浅。最后还是那句话，多读源码，多学习。</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a><span class="tag-list-count">2</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li></ul></div></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2017/05/20/Runtime/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2017/05/20/BulidBlog/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/iosTangtang" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/u/2942054403" title="Weibo" target="_blank"><i class="icon icon-weibo"></i></a></li><li><a href="http://zhihu.com/people/tang-tang-45-9-68" title="Zhihu" target="_blank"><i class="icon icon-zhihu"></i></a></li><li><a href="iosTangtang@163.com" title="Email" target="_blank"><i class="icon icon-email"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2017 iosTangtang<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>