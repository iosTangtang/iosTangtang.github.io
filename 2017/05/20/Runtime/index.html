<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="Be a better man"><meta name="keywords" content="Hexo, iOS"><title>Objc Runtime - iosTangtang</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/iosTangtang"><span>Github</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">Objc Runtime</h1><ul class="meta"><li><i class="icon icon-author"></i>iosTangtang</li><li><i class="icon icon-clock"></i>70 Minutes</li><li><i class="icon icon-calendar"></i>2017年5月20日</li></ul></div></div><div class="article-content" style="max-width:800px"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文主要是对Runtime学习的一部分总结，也是作为实验室讲课的资料，写的不好或者哪里不对的地方欢迎交流指正。</p>
<h2 id="知识结构"><a href="#知识结构" class="headerlink" title="知识结构"></a>知识结构</h2><p>主要从runtime的主要几个大点进行讲解。包括 </p>
<ul>
<li>何为Rumtime</li>
<li>类与对象<ol>
<li>类的结构(基础数据结构)</li>
<li>实例对象、类对象、元类之间的关系</li>
<li>类中对应的方法的结构</li>
</ol>
</li>
<li>消息转发机制</li>
<li>self与super的区别</li>
<li>简单应用</li>
</ul>
<h2 id="何为Runtime"><a href="#何为Runtime" class="headerlink" title="何为Runtime"></a>何为Runtime</h2><p>什么是Runtime呢？引用Apple官方的一段话</p>
<blockquote>
<p>The Objective-C language defers as many decisions as it can from compile time and link time to runtime. Whenever possible, it does things dynamically. This means that the language requires not just a compiler, but also a runtime system to execute the compiled code. The runtime system acts as a kind of operating system for the Objective-C language; it’s what makes the language work.</p>
</blockquote>
<p>这段话的意思大概就是，OC将一些静态语言在编译链接时做的事推迟到了编译链接之后，也就是运行时，这使得其更加灵活。这意味着OC不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。运行时机制就像一个操作系统一样，它让所有的工作能够正常的运行。<br>Objc Runtime其实就是一个Runtime库，底层实现基本上是用C/C++和汇编写的。对C语言结构体及函数进行封装，再实现一些特性，使程序在运行时能够创建、修改、检查类、对象以及对应的方法。</p>
<a id="more"></a>
<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>介绍Runtime，从最基本的类和对象的底层实现开始。这里使用的源码是Apple官方的最新Objc源代码(objc4-680)，在底层的类的结构部分有所不同，可以从<a href="http://opensource.apple.com//tarballs/objc4/" target="_blank" rel="external">这里</a>下载最新的源码。</p>
<h4 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a>类的结构</h4><p>我们从OC根类–NSObject开始跟踪</p>
<p>NSObject.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface NSObject &lt;NSObject&gt; &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果之前看过Runtime知识的你，对这个isa肯定不会陌生。可以看到这里的isa是个Class类型的，继续跟踪。</p>
<p>objc.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_class *Class;</div></pre></td></tr></table></figure>
<p>可以看到这里的Class是个<code>objc_class</code>类型的指针，那么这里的<code>objc_class</code>是什么呢？继续跟踪。</p>
<p>objc-runtime-old.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">struct objc_class : objc_object &#123;</div><div class="line">    Class superclass;</div><div class="line">    const char *name;</div><div class="line">    uint32_t version;</div><div class="line">    uint32_t info;</div><div class="line">    uint32_t instance_size;</div><div class="line">    struct old_ivar_list *ivars;</div><div class="line">    struct old_method_list **methodLists;</div><div class="line">    Cache cache;</div><div class="line">    struct old_protocol_list *protocols;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>objc-runtime-new.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct objc_class : objc_object &#123;</div><div class="line">    // Class ISA;</div><div class="line">    Class superclass;</div><div class="line">    cache_t cache;             // formerly cache pointer and vtable</div><div class="line">    class_data_bits_t bits;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里只截取部分的代码，该结构体的全部实现内容可以见源码。这里列出了两个版本的结构体定义，两个版本都是继承自objc_object结构体，旧版的定义方式很明了，从变量名就可以看出其对应的作用，本文只针对新版的进行解析，旧版的虽然结构体定义不一样，但是对整个runtime的理解影响不是很大。这里列一个表格说明旧版的部分变量的作用。</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量名</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">superclass</td>
<td style="text-align:center">指向父类的指针</td>
</tr>
<tr>
<td style="text-align:center">name</td>
<td style="text-align:center">变量名</td>
</tr>
<tr>
<td style="text-align:center">version</td>
<td style="text-align:center">类的版本信息，默认为0</td>
</tr>
<tr>
<td style="text-align:center">info</td>
<td style="text-align:center">类信息，供运行期使用的一些位标识</td>
</tr>
<tr>
<td style="text-align:center">instance_size</td>
<td style="text-align:center">类该类的实例变量大小</td>
</tr>
<tr>
<td style="text-align:center">ivars</td>
<td style="text-align:center">该类的成员变量列表</td>
</tr>
<tr>
<td style="text-align:center">methodLists</td>
<td style="text-align:center">该类的方法定义的链表</td>
</tr>
<tr>
<td style="text-align:center">cache</td>
<td style="text-align:center">方法的缓存</td>
</tr>
<tr>
<td style="text-align:center">protocols</td>
<td style="text-align:center">所包含的协议链表</td>
</tr>
</tbody>
</table>
<p>新版的定义较旧版的相比，看起来简洁了许多，可是这背后真的有那么简单吗？这个我们下一节来讨论。cache的作用同样是方法缓存，只不过新版的结构体类型不相同。这里的<code>class_data_bits_t</code>是之前没见过的一个结构体，你们可以猜猜这个是干嘛的，具体会在后面解释。</p>
<p>我们再来看看这个神秘的objc_object</p>
<p>objc_object.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct objc_object &#123;</div><div class="line">private:</div><div class="line">    isa_t isa;</div><div class="line"></div><div class="line">public:</div><div class="line"></div><div class="line">    // ISA() assumes this is NOT a tagged pointer object</div><div class="line">    Class ISA();</div><div class="line"></div><div class="line">    // getIsa() allows this to be a tagged pointer object</div><div class="line">    Class getIsa();</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样只截取了部分代码，具体可以参见源码。如果之前了解过isa的同学会发现，isa的类型变了，由原来的Class变为了<code>isa_t</code>。这种变化主要是为了优化其在<code>__arm64__</code>和<code>__x86_64__</code>二者的cpu上的内存使用，说通俗点就是在iOS和macOS上的内存优化。这里不对这个结构体进行过多阐述，你可以点击<a href="http://www.jianshu.com/p/e694678be145" target="_blank" rel="external">这里</a>来了解其作用。</p>
<h4 id="实例对象、类对象、元类之间的关系"><a href="#实例对象、类对象、元类之间的关系" class="headerlink" title="实例对象、类对象、元类之间的关系"></a>实例对象、类对象、元类之间的关系</h4><p>从上一节我们知道了类的数据结构，那么其中的isa指针是干嘛的呢？接触过Runtime的人应该多多少少了解一些。这里的isa牵扯到OC中类的实现及存储方式。我们都知道，OC中类的方法分为类方法和实例方法，这些方法分别是存在哪儿的？这里提几个名词，类对象和元类。</p>
<p>在OC中我们可以给对象发送消息，即调用实例方法，我们还可以像下面这样调用类方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSArray *array = [NSArray array];</div></pre></td></tr></table></figure>
<p>说明，在OC中，类其实也是一个对象，即<strong>类对象</strong>，所有的类的实例就是由类对象进行初始化得来的。既然类也是个对象，那它是由谁而来的？答案是<strong>元类</strong>。而连接这一切的，正是这个<strong>isa</strong>指针。<br><img src="http://upload-images.jianshu.io/upload_images/1975281-cc44a16eb3f252d3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类、类对象、元类之间的关系"></p>
<p>正如上图所示，实例对象、类对象、元类对象中都存在一个isa指针，实例对象的isa指针指向类对象，实例对象中存储着实例变量和属性，而实例方法存在于类对象中，这样设计的目的也是为了节省内存空间(想想如果每个实例对象都保存着自己能执行的方法，那么对内存将是很大的负担)。类对象所能响应的方法–类方法，存放在元类中，同样类对象的isa指针指向了元类，即如果你向类对象发送消息的话，会在元类中寻找对应的方法。元类的isa指针则指向了根类的元类，根类的元类的isa指针则指向了自己。</p>
<p>这里说明一下，类对象和元类在内存中各自仅存在一份，也就是说，二者皆为单例。原因很简单，对某个类的描述仅存在一份即可，需要时可通过此描述来克隆(说克隆也不是很对，大概意思)出其他的对象。实例对象既然是从类对象而来，那么我们可以从类对象这里得到很多实例对象，而类对象只需一个即可。同样元类也是一样，但是这里生成的类对象只需一份即可。</p>
<p>我们可以在代码中去验证这个关系链，举个例子。点击<a href="https://github.com/iosTangtang/RuntimeDemo.git" target="_blank" rel="external">这里</a>下载Demo。</p>
<p>ClassAndObject.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;point                           %p&quot;, &amp;self);</div><div class="line">NSLog(@&quot;instance                        %p&quot;, self);</div><div class="line">NSLog(@&quot;class                           %p&quot;, object_getClass(self));</div><div class="line">NSLog(@&quot;meta class                      %p&quot;, object_getClass([self class]));</div><div class="line">NSLog(@&quot;root class                      %p&quot;, object_getClass(object_getClass([self class])));</div><div class="line">NSLog(@&quot;root meta&apos;s meta class          %p&quot;, object_getClass(object_getClass(object_getClass([self class]))));</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;instance                        %@&quot;, self);</div><div class="line">NSLog(@&quot;class                           %@&quot;, object_getClass(self));</div><div class="line">NSLog(@&quot;meta class                      %@&quot;, object_getClass([self class]));</div><div class="line">NSLog(@&quot;root class                      %@&quot;, object_getClass(object_getClass([self class])));</div><div class="line">NSLog(@&quot;root meta&apos;s meta class          %@&quot;, object_getClass(object_getClass(object_getClass([self class]))));</div></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">2016-10-06 16:43:49.057 RuntimeDemo[2768:87818] &gt;&gt;&gt;&gt;&gt;&gt;ClassAndObject showAddressMethod&lt;&lt;&lt;&lt;&lt;&lt;</div><div class="line">2016-10-06 16:43:49.057 RuntimeDemo[2768:87818] point                           0x7fff527949a8</div><div class="line">2016-10-06 16:43:49.058 RuntimeDemo[2768:87818] instance                        0x618000005360</div><div class="line">2016-10-06 16:43:49.058 RuntimeDemo[2768:87818] class                           0x10d46c328</div><div class="line">2016-10-06 16:43:49.058 RuntimeDemo[2768:87818] meta class                      0x10d46c300</div><div class="line">2016-10-06 16:43:49.058 RuntimeDemo[2768:87818] root class                      0x10de09e08</div><div class="line">2016-10-06 16:43:49.058 RuntimeDemo[2768:87818] root meta&apos;s meta class          0x10de09e08</div><div class="line">2016-10-06 16:43:49.059 RuntimeDemo[2768:87818] &gt;&gt;&gt;&gt;&gt;&gt;ClassAndObject showRelationMethod&lt;&lt;&lt;&lt;&lt;&lt;</div><div class="line">2016-10-06 16:43:49.059 RuntimeDemo[2768:87818] instance                        &lt;ClassAndObject: 0x618000005360&gt;</div><div class="line">2016-10-06 16:43:49.059 RuntimeDemo[2768:87818] class                           ClassAndObject</div><div class="line">2016-10-06 16:43:49.059 RuntimeDemo[2768:87818] meta class                      ClassAndObject</div><div class="line">2016-10-06 16:43:49.718 RuntimeDemo[2768:87818] root class                      NSObject</div><div class="line">2016-10-06 16:43:49.718 RuntimeDemo[2768:87818] root meta&apos;s meta class          NSObject</div></pre></td></tr></table></figure>
<p>从打印结果来看，确实验证了我们的猜想，最后都走向了NSObject的元类。这里有一点需要注意，跟踪的时候，不能直接调用class方法，否则无法得到正确结果。这与class的实现有关，具体看<a href="http://www.jianshu.com/p/54c190542aa8" target="_blank" rel="external">这里</a>。</p>
<p>对元类的更多解释，点击<a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" target="_blank" rel="external">这里</a>了解(注: 该博客为英文，慎重食用)。</p>
<h4 id="类中对应的方法的结构"><a href="#类中对应的方法的结构" class="headerlink" title="类中对应的方法的结构"></a>类中对应的方法的结构</h4><p>这节来说说上面遗留的新版objc_class中的<code>class_data_bits_t</code>结构体，它究竟是用来干什么的？对比新旧两版的runtime可以发现，新版中对于成员变量列表、方法列表、协议列表的定义消失了，它们去哪儿了？我们顺着<code>class_data_bits_t</code>来跟踪下去。</p>
<p>objc-runtime-new.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct class_data_bits_t &#123;</div><div class="line"></div><div class="line">    // Values are the FAST_ flags above.</div><div class="line">    uintptr_t bits;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个结构体的变量就只有一个<code>bits</code>，似乎我们发现不了什么端倪，但是仔细看看objc_class结构体中对class_data_bits_t的注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</div></pre></td></tr></table></figure>
<p>这里注释写到，<code>class_data_bits_t</code>相当于<code>class_rw_t</code>加上<code>rr/alloc</code>，即提供了便携方法返回<code>class_rw_t *</code>指针。在<code>class_data_bits_t</code>结构体中寻找发现。</p>
<p>objc-runtime-new.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class_rw_t* data() &#123;</div><div class="line">    return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</div><div class="line">&#125;</div><div class="line">void setData(class_rw_t *newData)</div><div class="line">&#123;</div><div class="line">    assert(!data()  ||  (newData-&gt;flags &amp; (RW_REALIZING | RW_FUTURE)));</div><div class="line">    // Set during realization or construction only. No locking needed.</div><div class="line">    bits = (bits &amp; ~FAST_DATA_MASK) | (uintptr_t)newData;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即<code>class_data_bits_t</code>本质上还是<code>class_rw_t</code>指针。说明端倪还在<code>class_rw_t</code>中。继续跟踪。</p>
<p>objc-runtime-new.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">struct class_rw_t &#123;</div><div class="line">    uint32_t flags;</div><div class="line">    uint32_t version;</div><div class="line"></div><div class="line">    const class_ro_t *ro;</div><div class="line"></div><div class="line">    method_array_t methods;</div><div class="line">    property_array_t properties;</div><div class="line">    protocol_array_t protocols;</div><div class="line"></div><div class="line">    Class firstSubclass;</div><div class="line">    Class nextSiblingClass;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>果然，发现了属性列表、方法列表和协议列表。进入<code>class_ro_t</code>。</p>
<p>objc-runtime-new.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">struct class_ro_t &#123;</div><div class="line">    uint32_t flags;</div><div class="line">    uint32_t instanceStart;</div><div class="line">    uint32_t instanceSize;</div><div class="line">#ifdef __LP64__</div><div class="line">    uint32_t reserved;</div><div class="line">#endif</div><div class="line"></div><div class="line">    const uint8_t * ivarLayout;</div><div class="line">    </div><div class="line">    const char * name;</div><div class="line">    method_list_t * baseMethodList;</div><div class="line">    protocol_list_t * baseProtocols;</div><div class="line">    const ivar_list_t * ivars;</div><div class="line"></div><div class="line">    const uint8_t * weakIvarLayout;</div><div class="line">    property_list_t *baseProperties;</div><div class="line"></div><div class="line">    method_list_t *baseMethods() const &#123;</div><div class="line">        return baseMethodList;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样就非常清楚了。<code>class_ro_t</code>是保存类在编译时期就已经确定的属性、方法和协议，即编译时，<code>class_data_bits_t</code>的指向为<code>class_ro_t</code>变量，当程序运行起来时，调用方法强制将<code>class_rw_t</code>转换为<code>class_ro_t</code>，然后初始化一个<code>class_rw_t</code>结构体变量，设置ro值和flags值，最后设置正确的data即可。上述过程可以表示为如下。</p>
<p>编译时<br><img src="http://upload-images.jianshu.io/upload_images/1975281-96a53fc868406a0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译时"></p>
<p>运行时<br><img src="http://upload-images.jianshu.io/upload_images/1975281-0bbf368d247b4142.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>(图片引用自Draveness)</p>
<p>代码验证过程你可以点击<a href="http://www.jianshu.com/p/d7a60fc7b0a1" target="_blank" rel="external">这里</a>来查看思路。该博客的博主对此过程的跟踪挺详细的，这里就不做示例了。</p>
<h3 id="消息转发机制"><a href="#消息转发机制" class="headerlink" title="消息转发机制"></a>消息转发机制</h3><p>在介绍消息转发机制之前，先介绍下SEL、IMP、Method。</p>
<h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p>SEL又叫选择子，表示一个方法的selector的指针。定义为</p>
<p>objc.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_selector *SEL;</div></pre></td></tr></table></figure>
<p>很遗憾没找到objc_selector结构体。OC在编译的时候，会根据每一个方法的名字、参数序列，生成唯一的一个整型标识(地址)，即SEL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SEL sel = @selector(hello);</div><div class="line">NSLog(@&quot;sel             %p&quot;, sel);</div></pre></td></tr></table></figure>
<p>如上代码，会有如下结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sel             0x1049f77b0</div></pre></td></tr></table></figure>
<p>即生成了一个整型标识。这个SEL值，不管你的方法是在父类还是子类，还是完全不相关的两个类，只要方法名一样，SEL值就是一样的，即使参数类型不一样，但同样还是相同的。但是，参数个数不一样SEL的值就不一样。验证如下</p>
<p>ClassAndObject.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)hello:(NSInteger)index &#123;</div><div class="line">    NSLog(@&quot;&gt;&gt;&gt;&gt;&gt;&gt;ClassAndObject hello&lt;&lt;&lt;&lt;&lt;&lt;&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)showHelloMethodSEL &#123;</div><div class="line">    NSLog(@&quot;&gt;&gt;&gt;&gt;&gt;&gt;ClassAndObject showHelloMethodSEL&lt;&lt;&lt;&lt;&lt;&lt;&quot;);</div><div class="line">    SEL sel = @selector(hello:);</div><div class="line">    NSLog(@&quot;sel             %p&quot;, sel);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>MethodObject.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)hello:(NSString *)string &#123;</div><div class="line">    NSLog(@&quot;&gt;&gt;&gt;&gt;&gt;&gt;MethodObject hello&lt;&lt;&lt;&lt;&lt;&lt;&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)showHelloMethodSEL &#123;</div><div class="line">    NSLog(@&quot;&gt;&gt;&gt;&gt;&gt;&gt;MethodObject showHelloMethodSEL&lt;&lt;&lt;&lt;&lt;&lt;&quot;);</div><div class="line">    SEL sel = @selector(hello:);</div><div class="line">    NSLog(@&quot;sel             %p&quot;, sel);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2016-10-07 15:18:49.891 RuntimeDemo[6696:317089] &gt;&gt;&gt;&gt;&gt;&gt;MethodObject showHelloMethodSEL&lt;&lt;&lt;&lt;&lt;&lt;</div><div class="line">2016-10-07 15:18:49.891 RuntimeDemo[6696:317089] sel             0x10b3add82</div><div class="line">2016-10-07 15:18:49.891 RuntimeDemo[6696:317089] &gt;&gt;&gt;&gt;&gt;&gt;ClassAndObject showHelloMethodSEL&lt;&lt;&lt;&lt;&lt;&lt;</div><div class="line">2016-10-07 15:18:49.891 RuntimeDemo[6696:317089] sel             0x10b3add82</div></pre></td></tr></table></figure>
<p>可以发现，SEL的值是一样的。</p>
<p>工程中的所有的SEL组成一个Set集合，Set的特点就是唯一，因此SEL是唯一的。相当于OC给我们维护了一张巨大的表，在编译的时候将所有的方法以及使用<code>@selector()</code>生成的选择子都存入这个集合中，在查找的时候，如果发现表中没有，将当前的选择子也存入集合中。SEL实际上是根据方法名hash化的字符串，对于字符串只要比较其地址即可，所以在查找的时候，速度是非常快的。但是这里可能存在一个缺陷，当你的方法数量变大，会增加hash冲突而导致性能下降，只要能够将数量变少，这个方法还是不错的。</p>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p>IMP就相当于一个函数指针，指向对应的方法实现。</p>
<p>objc.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#if !OBJC_OLD_DISPATCH_PROTOTYPES</div><div class="line">typedef void (*IMP)(void /* id, SEL, ... */ ); </div><div class="line">#else</div><div class="line">typedef id (*IMP)(id, SEL, ...); </div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>第一个参数是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是方法选择器(selector)，接下来是方法的实际参数列表。每个SEL都对应一个IMP，通过查找SEL就可以找到IMP，即可获得函数的实现。</p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>Method的结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_method *Method;</div><div class="line"></div><div class="line">struct objc_method &#123;</div><div class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</div><div class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</div><div class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</div><div class="line">&#125;                                                            OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p>从Method的结构就可以看出来，这个结构体就是连接SEL和IMP的，即有了这个结构体，我们就可以实现一个SEL对应一个IMP。</p>
<h4 id="方法调用流程"><a href="#方法调用流程" class="headerlink" title="方法调用流程"></a>方法调用流程</h4><p>在OC中，我们像如下这样调用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self runtime_method];</div></pre></td></tr></table></figure>
<p>这个表达式会转换为一个方法调用，即<code>objc_msgSend</code>。该函数的定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OBJC_EXPORT id objc_msgSend(id self, SEL op, ...)</div></pre></td></tr></table></figure>
<p>这个函数完成了动态绑定的所有事情：</p>
<ol>
<li><p>首先它找到selector对应的方法实现。因为同一个方法可能在不同的类中有不同的实现，所以我们需要依赖于接收者的类来找到的确切的实现。</p>
</li>
<li><p>它调用方法实现，并将接收者对象及方法的所有参数传给它。</p>
</li>
<li><p>最后，它将实现返回的值作为它自己的返回值。</p>
</li>
</ol>
<p>下图展示了发送一个消息查找的基本流程<br><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/messaging1.gif" alt="消息查找"></p>
<p>当消息发送给一个对象时，<code>objc_msgSend</code>通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。如果 没有找到selector，则通过<code>objc_msgSend</code>结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。依 此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实 现。如果最后没有定位到selector，则会走消息转发流程。为了加速消息的处理，运行时系统缓存使用过的selector及对应的方法的地址。</p>
<h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><p>如果当前调用的方法不存在的话，就会触发消息转发机制，通过这一机制，我们可以告诉对象如何处理未知消息。消息转发机制主要分为以下三个步骤。</p>
<ol>
<li>动态方法解析</li>
<li>备用接收者</li>
<li>完整的消息转发</li>
</ol>
<h4 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><p>对象在接收到未知消息的时候，首先会调用所属类的类方法<code>+resolveInstanceMethod:</code>或<code>+resolveClassMethod:</code>，在这个方法中，我们可以为该未知消息新增一个处理方法。前提是我们需要实现该方法。</p>
<p>MethodObject.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void functionMethod(void) &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//实例方法</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    </div><div class="line">    NSString *selSelector = NSStringFromSelector(sel);</div><div class="line">    </div><div class="line">    if ([selSelector isEqualToString:@&quot;method&quot;]) &#123;</div><div class="line">        class_addMethod([self class], @selector(method), (IMP)functionMethod, &quot;@:&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2016-10-07 16:16:38.983 RuntimeDemo[7390:366991] +[MethodObject resolveInstanceMethod:]</div><div class="line">2016-10-07 16:16:38.983 RuntimeDemo[7390:366991] functionMethod</div></pre></td></tr></table></figure>
<h4 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h4><p>如果上一步无法处理，那么Runtime就会继续调用下面的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p>使用这个方法通常是在对象内部，可能还有一系列其它对象能处理该消息，我们便可借这些对象来处理消息并返回，这样在对象外部看来，还是由该对象亲自处理了这一消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@interface MethodHelper : NSObject</div><div class="line"></div><div class="line">- (void)method;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation MethodHelper</div><div class="line"></div><div class="line">- (void)method &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@interface MethodObject () &#123;</div><div class="line">    MethodHelper *_helper;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    </div><div class="line">    NSString *selSelector = NSStringFromSelector(aSelector);</div><div class="line">    </div><div class="line">    if ([selSelector isEqualToString:@&quot;method&quot;]) &#123;</div><div class="line">        return _helper;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return [super forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(这里注意方法名需要一样)</p>
<p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p>
<h4 id="完整的消息转发"><a href="#完整的消息转发" class="headerlink" title="完整的消息转发"></a>完整的消息转发</h4><p>若上一步还是无法处理，则会启用完整的消息转发机制。调用以下方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</div></pre></td></tr></table></figure>
<p>运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。对象会创建一个表示消息的NSInvocation对象，把与尚未处理的消息 有关的全部细节都封装在anInvocation中，包括selector，目标(target)和参数。我们可以在forwardInvocation 方法中选择将消息转发给其它对象。</p>
<p>forwardInvocation:方法的实现有两个任务：</p>
<ol>
<li>定位可以响应封装在anInvocation中的消息的对象。这个对象不需要能处理所有未知消息。</li>
<li>使用anInvocation作为参数，将消息发送到选中的对象。anInvocation将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。</li>
</ol>
<p>在这个方法中我们可以实现一些更复杂的功能，我们可以对消息的内容进行修改，比如追回一个参数等，然后再去触发消息。另外，若发现某个消息不应由本类处理，则应调用父类的同名方法，以便继承体系中的每个类都有机会处理此调用请求。</p>
<p>在这一步中，我们必须重写下面这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p>消息转发机制使用从这个方法中获取的信息来创建NSInvocation对象。因此我们必须重写这个方法，为给定的selector提供一个合适的方法签名。</p>
<p>例子</p>
<p>MethodObject.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    </div><div class="line">    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];</div><div class="line">    </div><div class="line">    if (!signature) &#123;</div><div class="line">        if ([MethodHelper instancesRespondToSelector:aSelector]) &#123;</div><div class="line">            signature = [MethodHelper instanceMethodSignatureForSelector:aSelector];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return signature;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    </div><div class="line">    if ([MethodHelper instancesRespondToSelector:anInvocation.selector]) &#123;</div><div class="line">        [anInvocation invokeWithTarget:_helper];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">2016-10-07 18:45:58.859 RuntimeDemo[8154:423365] +[MethodObject resolveInstanceMethod:]</div><div class="line">2016-10-07 18:45:58.860 RuntimeDemo[8154:423365] -[MethodObject forwardingTargetForSelector:]</div><div class="line">2016-10-07 18:45:58.860 RuntimeDemo[8154:423365] -[MethodObject methodSignatureForSelector:]</div><div class="line">2016-10-07 18:45:58.860 RuntimeDemo[8154:423365] +[MethodObject resolveInstanceMethod:]</div><div class="line">2016-10-07 18:45:58.861 RuntimeDemo[8154:423365] -[MethodObject forwardInvocation:]</div><div class="line">2016-10-07 18:45:58.861 RuntimeDemo[8154:423365] -[MethodHelper method]</div></pre></td></tr></table></figure>
<p>从上也可以看出整个消息转发过程。</p>
<p>NSObject的forwardInvocation:方法实现只是简单调用了doesNotRecognizeSelector:方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。</p>
<p>forwardInvocation:就像一个未知消息的分发中心，将这些未知的消息转发给其它对象。或者也可以像一个运输站一样将所有未知消息都发送给同一个接收对象。</p>
<h4 id="深入Objc-msgSend"><a href="#深入Objc-msgSend" class="headerlink" title="深入Objc_msgSend"></a>深入Objc_msgSend</h4><p>本小节主要讲下OC中消息的发送过程，也可以说是方法的查找过程。主要步骤如下</p>
<ol>
<li>缓存是否命中</li>
<li>查找当前类的缓存及方法</li>
<li>查找父类的缓存及方法</li>
<li>方法决议(即消息转发机制的第一步，动态方法解析)</li>
<li>消息转发</li>
</ol>
<h4 id="无缓存"><a href="#无缓存" class="headerlink" title="无缓存"></a>无缓存</h4><p>无缓存，即方法为第一次调用，暂时没有缓存到缓存池中。可以跟踪一下objc_msgSend方法的调用栈，调用栈如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0 lookUpImpOrForward</div><div class="line">1 _class_lookupMethodAndLoadCache3</div><div class="line">2 objc_msgSend</div><div class="line">3 main</div><div class="line">4 start</div></pre></td></tr></table></figure>
<p>可以发现，<code>objc_msgSend</code>之后，还随之调用了两个方法，首先调用的是<code>_class_lookupMethodAndLoadCache3</code>，跟踪进去看看其实现如下</p>
<p>objc-runtime-new.mm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)</div><div class="line">&#123;</div><div class="line">    return lookUpImpOrForward(cls, sel, obj, </div><div class="line">                              YES/*initialize*/, NO/*cache*/, YES/*resolver*/);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这个方法只是对第二个方法<code>lookUpImpOrForward</code>的调用，而这个方法，正是查找的主方法，这个方法内部调用的方法很多，有兴趣可以去objc-class-old.mm里面去查看源码。说说它的主要步骤</p>
<ol>
<li>无锁的缓存查找</li>
<li>如果类没有实现（isRealized）或者初始化（isInitialized），实现或者初始化类</li>
<li>加锁</li>
<li>缓存以及当前类中方法的查找</li>
<li>尝试查找父类的缓存以及方法列表</li>
<li>没有找到实现，尝试方法解析器</li>
<li>进行消息转发</li>
<li>解锁、返回实现</li>
</ol>
<h4 id="无锁的缓存查找"><a href="#无锁的缓存查找" class="headerlink" title="无锁的缓存查找"></a>无锁的缓存查找</h4><p>在没有加锁的情况下，对缓存进行查找，提高查找效率。当然如果是第一次调用方法的话，这个步骤会跳过。</p>
<p>源代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">methodListLock.assertUnlocked();</div><div class="line"></div><div class="line"> // Optimistic cache lookup</div><div class="line"> if (cache) &#123;</div><div class="line">        methodPC = _cache_getImp(cls, sel);</div><div class="line">        if (methodPC) return methodPC;    </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h4 id="类的实现和初始化"><a href="#类的实现和初始化" class="headerlink" title="类的实现和初始化"></a>类的实现和初始化</h4><p>在运行中会对类进行第一次初始化，初始化调用<code>realizeClass</code>方法。</p>
<p>源代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if (cls == _class_getFreedObjectClass())</div><div class="line">        return (IMP) _freedHandler;</div><div class="line"></div><div class="line"> // Check for +initialize</div><div class="line"> if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</div><div class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</div><div class="line">        // If sel == initialize, _class_initialize will send +initialize and </div><div class="line">        // then the messenger will send +initialize again after this </div><div class="line">        // procedure finishes. Of course, if this is not being called </div><div class="line">        // from the messenger then it won&apos;t happen. 2778172</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>加锁的代码只有一行，其主要目的保证方法查找以及缓存填充（cache-fill）的原子性，保证在运行以下代码时不会有新方法添加导致缓存被清除（flush）。</p>
<p>源代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">methodListLock.lock();</div></pre></td></tr></table></figure>
<h4 id="查找当前类"><a href="#查找当前类" class="headerlink" title="查找当前类"></a>查找当前类</h4><p>源代码中的实现，调用了<code>_cache_getImp()</code>方法。</p>
<p>源代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">methodPC = _cache_getImp(cls, sel);</div><div class="line">if (methodPC) goto done;</div></pre></td></tr></table></figure>
<p><code>_cache_getImp()</code>方法并不是开源的，Apple在这块儿使用了汇编来实现这个方法，原因很简单，就是保证了查找的高效性。</p>
<p>如果在缓存中找到了方法，就会调到done标签。如果没有，就会执行下面代码</p>
<p>源代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">meth = _class_getMethodNoSuper_nolock(cls, sel);</div><div class="line">if (meth) &#123;</div><div class="line">        log_and_fill_cache(cls, cls, meth, sel);</div><div class="line">        methodPC = method_getImplementation(meth);</div><div class="line">        goto done;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是在当前类中对查找所对应的方法。</p>
<p>源代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">static Method _class_getMethodNoSuper_nolock(Class cls, SEL sel)</div><div class="line">&#123;</div><div class="line">    methodListLock.assertLocked();</div><div class="line">    return (Method)_findMethodInClass(cls, sel);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static inline old_method * _findMethodInClass(Class cls, SEL sel) &#123;</div><div class="line">    // Flattened version of nextMethodList(). The optimizer doesn&apos;t </div><div class="line">    // do a good job with hoisting the conditionals out of the loop.</div><div class="line">    // Conceptually, this looks like:</div><div class="line">    // while ((mlist = nextMethodList(cls, &amp;iterator))) &#123;</div><div class="line">    //     old_method *m = _findMethodInList(mlist, sel);</div><div class="line">    //     if (m) return m;</div><div class="line">    // &#125;</div><div class="line"></div><div class="line">    if (!cls-&gt;methodLists) &#123;</div><div class="line">        // No method lists.</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    else if (cls-&gt;info &amp; CLS_NO_METHOD_ARRAY) &#123;</div><div class="line">        // One method list.</div><div class="line">        old_method_list **mlistp;</div><div class="line">        mlistp = (old_method_list **)&amp;cls-&gt;methodLists;</div><div class="line">        *mlistp = fixupSelectorsInMethodList(cls, *mlistp);</div><div class="line">        return _findMethodInList(*mlistp, sel);</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        // Multiple method lists.</div><div class="line">        old_method_list **mlistp;</div><div class="line">        for (mlistp = cls-&gt;methodLists; </div><div class="line">             *mlistp != nil  &amp;&amp;  *mlistp != END_OF_METHODS_LIST; </div><div class="line">             mlistp++) </div><div class="line">        &#123;</div><div class="line">            old_method *m;</div><div class="line">            *mlistp = fixupSelectorsInMethodList(cls, *mlistp);</div><div class="line">            m = _findMethodInList(*mlistp, sel);</div><div class="line">            if (m) return m;</div><div class="line">        &#125;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现中有许多小细节，包括如何查找、查找到需要加入缓存、缓存内容大于容量的3/4的时候会清空缓存、清空缓存时会将缓存清空等。有兴趣的可以去源码中查看理解。</p>
<h4 id="在父类中查找"><a href="#在父类中查找" class="headerlink" title="在父类中查找"></a>在父类中查找</h4><p>源代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">curClass = cls;</div><div class="line">    while ((curClass = curClass-&gt;superclass)) &#123;</div><div class="line">        // Superclass cache.</div><div class="line">        meth = _cache_getMethod(curClass, sel, _objc_msgForward_impcache);</div><div class="line">        if (meth) &#123;</div><div class="line">            if (meth != (Method)1) &#123;</div><div class="line">                // Found the method in a superclass. Cache it in this class.</div><div class="line">                log_and_fill_cache(cls, curClass, meth, sel);</div><div class="line">                methodPC = method_getImplementation(meth);</div><div class="line">                goto done;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                // Found a forward:: entry in a superclass.</div><div class="line">                // Stop searching, but don&apos;t cache yet; call method </div><div class="line">                // resolver for this class first.</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Superclass method list.</div><div class="line">        meth = _class_getMethodNoSuper_nolock(curClass, sel);</div><div class="line">        if (meth) &#123;</div><div class="line">            log_and_fill_cache(cls, curClass, meth, sel);</div><div class="line">            methodPC = method_getImplementation(meth);</div><div class="line">            goto done;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>实现过程也是差不多的，先查找缓存，之后查找方法列表。</p>
<h4 id="没有找到实现，尝试方法解析器"><a href="#没有找到实现，尝试方法解析器" class="headerlink" title="没有找到实现，尝试方法解析器"></a>没有找到实现，尝试方法解析器</h4><p>源代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (resolver  &amp;&amp;  !triedResolver) &#123;</div><div class="line">        methodListLock.unlock();</div><div class="line">        _class_resolveMethod(cls, sel, inst);</div><div class="line">        triedResolver = YES;</div><div class="line">        goto retry;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，这里就在进行方法决议，即进行消息转发第一阶段–动态方法解析。当然是建立在都没有查找到方法的情况下。</p>
<p>源代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void _class_resolveMethod(Class cls, SEL sel, id inst)</div><div class="line">&#123;</div><div class="line">    if (! cls-&gt;isMetaClass()) &#123;</div><div class="line">        // try [cls resolveInstanceMethod:sel]</div><div class="line">        _class_resolveInstanceMethod(cls, sel, inst);</div><div class="line">    &#125; </div><div class="line">    else &#123;</div><div class="line">        // try [nonMetaClass resolveClassMethod:sel]</div><div class="line">        // and [cls resolveInstanceMethod:sel]</div><div class="line">        _class_resolveClassMethod(cls, sel, inst);</div><div class="line">        if (!lookUpImpOrNil(cls, sel, inst, </div><div class="line">                            NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) </div><div class="line">        &#123;</div><div class="line">            _class_resolveInstanceMethod(cls, sel, inst);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这段代码更容易看出，其实就是在调用<code>+resolveInstanceMethod:</code>或<code>+resolveClassMethod:</code>两个方法来出来消息。</p>
<h4 id="消息转发-1"><a href="#消息转发-1" class="headerlink" title="消息转发"></a>消息转发</h4><p>最后，若未处理成功，进入消息转发的第二第三阶段。</p>
<p>源代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_cache_addForwardEntry(cls, sel);</div><div class="line">methodPC = _objc_msgForward_impcache;</div></pre></td></tr></table></figure>
<p>这样就进行了第一次调用方法的整个过程。思路还是挺好理解的，也很符合逻辑。当第二次调用该方法时，跟踪发现，整个过程变化很大，不会调用<code>lookUpImpOrForward</code>，也就是说，方法缓存调用直接在<code>objc_msgSend</code>方法中就实现了。</p>
<p>其实<code>objc_msgSend</code>方法也是使用汇编编写的，在其中加入了缓存查找的实现，当然这一切都是为了查找的高效性。</p>
<p>讲到这，整个方法的调用过程也差不多讲完了，其实思路还是很好理解的，就是实现中的一些小细节的问题。</p>
<h2 id="self与super的区别"><a href="#self与super的区别" class="headerlink" title="self与super的区别"></a>self与super的区别</h2><p>self和super两个是不同的，self是类的一个隐藏参数，每个方法的实现的第一个参数即为self。而super不是一个隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用viewDidLoad方法时，去调用父类的方法，而不是本类中的方法。我们可以看看super的定义。</p>
<p>message.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#ifndef OBJC_SUPER</div><div class="line">#define OBJC_SUPER</div><div class="line"></div><div class="line">/// Specifies the superclass of an instance. </div><div class="line">struct objc_super &#123;</div><div class="line">    /// Specifies an instance of a class.</div><div class="line">    __unsafe_unretained id receiver;</div><div class="line"></div><div class="line">    /// Specifies the particular superclass of the instance to message. </div><div class="line">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</div><div class="line">    /* For compatibility with old objc-runtime.h header */</div><div class="line">    __unsafe_unretained Class class;</div><div class="line">#else</div><div class="line">    __unsafe_unretained Class super_class;</div><div class="line">#endif</div><div class="line">    /* super_class is the first class to search */</div><div class="line">&#125;;</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>这个结构体，抛去这些宏判断不看，实际上可以看成是包含了两个变量，<code>receiver</code>是消息的实际接收者，<code>super_class</code>是指向当前类的父类。当我们使用super来接收消息时，编译器会生成一个objc_super结构体。发送消息时，就不是使用<code>objc_msgSend</code>方法了，而是<code>objc_msgSendSuper</code>，其声明如下</p>
<p>message.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id objc_msgSendSuper(struct objc_super *super, SEL op, ...)</div></pre></td></tr></table></figure>
<p>其实跟<code>objc_msgSend</code>类似，只是第一个参数不再是self了，而是生成的super结构体。该函数实际的操作是：从objc_super结构体指向的superClass的方法列表开始查找调用方法的selector，找到后以objc-&gt;receiver去调用这个selector，而此时的操作流程就是如下方式了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(objc_super-&gt;receiver, @selector(xxxxx))</div></pre></td></tr></table></figure>
<p>其实，<code>objc_super-&gt;receiver</code>就相当于<code>self</code>，上面的操作其实也就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(self, @selector(xxxxx))</div></pre></td></tr></table></figure>
<p>其实就相当于父类调用了那个方法，发送了消息。</p>
<h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><p>关于Runtime的应用有挺多的，<a href="http://gold.xitu.io/entry/57f26be0a0bb9f00580a4ba7" target="_blank" rel="external">这里</a>总结的挺多的。本节就提几个常用的。</p>
<ul>
<li>Method Swizzling</li>
<li>Associated Object关联对象</li>
<li>动态的增加方法</li>
<li>字典和模型互相转换</li>
</ul>
<h4 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h4><p>这个算Runtime的一个黑魔法，可以在运行中动态交换方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">+ (void)load &#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        Class class = [self class];</div><div class="line">        </div><div class="line">        SEL originalSelector = @selector(methodExchange1);</div><div class="line">        SEL swizzledSelector = @selector(methodExchange2);</div><div class="line">        </div><div class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class="line">        </div><div class="line">        BOOL didAddMethod =</div><div class="line">        class_addMethod(class,</div><div class="line">                        originalSelector,</div><div class="line">                        method_getImplementation(swizzledMethod),</div><div class="line">                        method_getTypeEncoding(swizzledMethod));</div><div class="line">        </div><div class="line">        if (didAddMethod) &#123;</div><div class="line">            class_replaceMethod(class,</div><div class="line">                                swizzledSelector,</div><div class="line">                                method_getImplementation(originalMethod),</div><div class="line">                                method_getTypeEncoding(originalMethod));</div><div class="line">        &#125; else &#123;</div><div class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)methodExchange1 &#123;</div><div class="line">    NSLog(@&quot;change method %s&quot;, __FUNCTION__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)methodExchange2 &#123;</div><div class="line">    NSLog(@&quot;&gt;&gt;&gt;&gt;&gt;&gt;RuntimeObject MethodExchange&lt;&lt;&lt;&lt;&lt;&lt;&quot;);</div><div class="line">    </div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    </div><div class="line">    [self methodExchange2];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2016-10-07 21:45:25.534 RuntimeDemo[9715:524715] &gt;&gt;&gt;&gt;&gt;&gt;RuntimeObject methodExchange&lt;&lt;&lt;&lt;&lt;&lt;</div><div class="line">2016-10-07 21:45:25.534 RuntimeDemo[9715:524715] -[RuntimeObject methodExchange2]</div><div class="line">2016-10-07 21:45:25.534 RuntimeDemo[9715:524715] change method -[RuntimeObject methodExchange1]</div></pre></td></tr></table></figure>
<p>这里要注意两个问题</p>
<ul>
<li>Swizzling应该总是在+load中执行</li>
<li>Swizzling应该总是在dispatch_once中执行</li>
</ul>
<h4 id="Swizzling应该总是在-load中执行"><a href="#Swizzling应该总是在-load中执行" class="headerlink" title="Swizzling应该总是在+load中执行"></a>Swizzling应该总是在+load中执行</h4><p>在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证—事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。</p>
<h4 id="Swizzling应该总是在dispatch-once中执行"><a href="#Swizzling应该总是在dispatch-once中执行" class="headerlink" title="Swizzling应该总是在dispatch_once中执行"></a>Swizzling应该总是在dispatch_once中执行</h4><p>与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践。</p>
<h4 id="Associated-Object关联对象"><a href="#Associated-Object关联对象" class="headerlink" title="Associated Object关联对象"></a>Associated Object关联对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 设置关联对象</div><div class="line">void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );</div><div class="line"></div><div class="line">// 获取关联对象</div><div class="line">id objc_getAssociatedObject ( id object, const void *key );</div><div class="line"></div><div class="line">// 移除关联对象</div><div class="line">void objc_removeAssociatedObjects ( id object );</div></pre></td></tr></table></figure>
<p>主要就是使用以上几个方法来关联对象。</p>
<p>举例说明使用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#import &quot;RuntimeObject.h&quot;</div><div class="line"></div><div class="line">@interface RuntimeObject (associated)</div><div class="line"></div><div class="line">@property (nonatomic, strong) id associatedObject;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">#import &quot;RuntimeObject+associated.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation RuntimeObject (associated)</div><div class="line">@dynamic associatedObject;</div><div class="line"></div><div class="line">- (void)setAssociatedObject:(id)associatedObject &#123;</div><div class="line">    NSLog(@&quot;&gt;&gt;&gt;&gt;&gt;&gt;RuntimeObject+associated associatedObject&lt;&lt;&lt;&lt;&lt;&lt;&quot;);</div><div class="line">    </div><div class="line">    objc_setAssociatedObject(self, @selector(associatedObject), associatedObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)associatedObject &#123;</div><div class="line">    return objc_getAssociatedObject(self, @selector(associatedObject));</div><div class="line">&#125;</div><div class="line"></div><div class="line">[run setAssociatedObject:@&quot;runtime_runtimeObject_associated&quot;];</div><div class="line">    </div><div class="line">NSLog(@&quot;%@&quot;, run.associatedObject);</div></pre></td></tr></table></figure>
<p>主要是用在给系统类采用类别来自定义添加部分属性。</p>
<h4 id="动态的增加方法"><a href="#动态的增加方法" class="headerlink" title="动态的增加方法"></a>动态的增加方法</h4><p>这块在之前的消息转发第一阶段的<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>里面提到过，这里就不再详说。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    </div><div class="line">    NSString *selSelector = NSStringFromSelector(sel);</div><div class="line">    </div><div class="line">    if ([selSelector isEqualToString:@&quot;method&quot;]) &#123;</div><div class="line">        class_addMethod([self class], @selector(method), (IMP)functionMethod, &quot;@:&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="字典和模型互相转换"><a href="#字典和模型互相转换" class="headerlink" title="字典和模型互相转换"></a>字典和模型互相转换</h4><p>这块应用就很广了，有许多字典转模型的框架，主要思想就是获取模型中的属性然后一一对应上去。这里就不做详说，可以参考大部分的字典转模型框架。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Runtime其实细节也是挺多的，这里只是对偏底层的东西说明一下，具体的有兴趣可以去看源码。</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a><span class="tag-list-count">2</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li></ul></div></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2017/05/20/Block/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2017/05/20/BulidBlog/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/iosTangtang" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/u/2942054403" title="Weibo" target="_blank"><i class="icon icon-weibo"></i></a></li><li><a href="http://zhihu.com/people/tang-tang-45-9-68" title="Zhihu" target="_blank"><i class="icon icon-zhihu"></i></a></li><li><a href="iosTangtang@163.com" title="Email" target="_blank"><i class="icon icon-email"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2017 iosTangtang<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>